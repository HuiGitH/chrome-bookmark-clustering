(lp0
S'http://typing.io/lesson/python/mercurial/merge.py/1'
p1
aS'Typing Lessons | typing.io'
p2
aI0
aV<!doctype html><html lang=en><head><script>window.J=window.J||{};var J=window.J;(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b;a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)};a[b].l=1*new Date;c=e.createElement(f);d=e.getElementsByTagName(f)[0];c.async=1;c.src=g;d.parentNode.insertBefore(c,d)})(window,document,"script","//www.google-analytics.com/analytics.js","ga");ga("create","UA-44205340-1");ga("send","pageview");</script><script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script><script src="//cdn.optimizely.com/js/2908640249.js"></script><script>window.optimizely=window.optimizely||[];window.optimizely.push(["activate"]);</script><script type="text/javascript">(function(f,b){if(!b.__SV){var a,e,k,g;window.mixpanel=b;b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!==typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};k="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");\u000afor(g=0;g<k.length;g++)f(c,k[g]);b._i.push([a,e,d])};b.__SV=1.2;a=f.createElement("script");a.type="text/javascript";a.async=!0;a.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";e=f.getElementsByTagName("script")[0];e.parentNode.insertBefore(a,e)}})(document,window.mixpanel||[]);mixpanel.init("b81171472312ba8707ed54c5c1e53f73");</script><script async src="/static/js/g45NX.js"></script><meta charset=utf-8><link href='//fonts.googleapis.com/css?family=PT+Sans|Ubuntu+Mono' rel=stylesheet type='text/css'><link rel=stylesheet href="/static/css/KLfXO.css" type="text/css" charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Typing Test in Python: Practice typing Python</title><meta name=description content="Practice typing with open source Python code from the Mercurial project, Distributed Version Control."><link rel=canonical href="http://typing.io/lesson/python/mercurial/merge.py/1"><meta name=viewport content="width=device-width,initial-scale=1"></head><!--[if lt IE 9]><body class="lt-ie9 lt-ie10 no-js"><![endif]--><!--[if IE 9]><body class="lt-ie10 no-js"><![endif]--><!--[if gt IE 9]><!--><body class=no-js><!--<![endif]--><script>var docElement=document.body;docElement.className=docElement.className.replace(/(^|\u005cs)no-js(\u005cs|$)/,"$1$2");</script><div class=loading-overlay><div class=loading-spinner></div></div><div class=header-wrapper><div class=header><div class=logo><a href="/" class=index><span class=t>typing</span>.io</a></div><div class=subnav><a class=analytics href="/analytics">analytics</a><a class=pricing href="/pricing">plans & pricing</a><a class=lessons href="/lessons">lessons</a><span class=userwrapper><span class="user popOutBtn" tabindex=0><span class=username></span></span><div class=bubble><a class="popOutBtn signout" tabindex=0>sign out</a></div></span><a class=signin data-label=header>sign in</a></div></div></div><div id=notifications><div class=close>Close </div></div><div id=main><div class=lesson><pre class=code># merge.py - directory-level update/merge handling for Mercurial\u000a#\u000a# Copyright 2006, 2007 Matt Mackall &lt;mpm@selenic.com&gt;\u000a#\u000a# This software may be used and distributed according to the terms of the\u000a# GNU General Public License version 2 or any later version.\u000a\u000afrom node import nullid, nullrev, hex, bin\u000afrom i18n import _\u000aimport scmutil, util, filemerge, copies, subrepo\u000aimport errno, os, shutil\u000a\u000aclass mergestate(object):\u000a    &#39;&#39;&#39;track 3-way merge state of individual files&#39;&#39;&#39;\u000a    def __init__(self, repo):\u000a        self._repo = repo\u000a        self._dirty = False\u000a        self._read()\u000a    def reset(self, node=None):\u000a        self._state = {}\u000a        if node:\u000a            self._local = node\u000a        shutil.rmtree(self._repo.join(&quot;merge&quot;), True)\u000a        self._dirty = False\u000a    def _read(self):\u000a        self._state = {}\u000a        try:\u000a            f = self._repo.opener(&quot;merge/state&quot;)\u000a            for i, l in enumerate(f):\u000a                if i == 0:\u000a                    self._local = bin(l[:-1])\u000a                else:\u000a                    bits = l[:-1].split(&quot;\u005c0&quot;)\u000a                    self._state[bits[0]] = bits[1:]\u000a            f.close()\u000a        except IOError, err:\u000a            if err.errno != errno.ENOENT:\u000a                raise\u000a        self._dirty = False\u000a    def commit(self):\u000a        if self._dirty:\u000a            f = self._repo.opener(&quot;merge/state&quot;, &quot;w&quot;)\u000a            f.write(hex(self._local) + &quot;\u005cn&quot;)\u000a            for d, v in self._state.iteritems():\u000a                f.write(&quot;\u005c0&quot;.join([d] + v) + &quot;\u005cn&quot;)\u000a            f.close()\u000a            self._dirty = False\u000a    def add(self, fcl, fco, fca, fd, flags):\u000a        hash = util.sha1(fcl.path()).hexdigest()\u000a        self._repo.opener.write(&quot;merge/&quot; + hash, fcl.data())\u000a        self._state[fd] = [&#39;u&#39;, hash, fcl.path(), fca.path(),\u000a                           hex(fca.filenode()), fco.path(), flags]\u000a        self._dirty = True\u000a    def __contains__(self, dfile):\u000a        return dfile in self._state\u000a    def __getitem__(self, dfile):\u000a        return self._state[dfile][0]\u000a    def __iter__(self):\u000a        l = self._state.keys()\u000a        l.sort()\u000a        for f in l:\u000a            yield f\u000a    def mark(self, dfile, state):\u000a        self._state[dfile][0] = state\u000a        self._dirty = True\u000a    def resolve(self, dfile, wctx, octx):\u000a        if self[dfile] == &#39;r&#39;:\u000a            return 0\u000a        state, hash, lfile, afile, anode, ofile, flags = self._state[dfile]\u000a        f = self._repo.opener(&quot;merge/&quot; + hash)\u000a        self._repo.wwrite(dfile, f.read(), flags)\u000a        f.close()\u000a        fcd = wctx[dfile]\u000a        fco = octx[ofile]\u000a        fca = self._repo.filectx(afile, fileid=anode)\u000a        r = filemerge.filemerge(self._repo, self._local, lfile, fcd, fco, fca)\u000a        if r is None:\u000a            # no real conflict\u000a            del self._state[dfile]\u000a        elif not r:\u000a            self.mark(dfile, &#39;r&#39;)\u000a        return r\u000a\u000adef _checkunknownfile(repo, wctx, mctx, f):\u000a    return (not repo.dirstate._ignore(f)\u000a        and os.path.isfile(repo.wjoin(f))\u000a        and repo.dirstate.normalize(f) not in repo.dirstate\u000a        and mctx[f].cmp(wctx[f]))\u000a\u000adef _checkunknown(repo, wctx, mctx):\u000a    &quot;check for collisions between unknown files and files in mctx&quot;\u000a\u000a    error = False\u000a    for f in mctx:\u000a        if f not in wctx and _checkunknownfile(repo, wctx, mctx, f):\u000a            error = True\u000a            wctx._repo.ui.warn(_(&quot;%s: untracked file differs\u005cn&quot;) % f)\u000a    if error:\u000a        raise util.Abort(_(&quot;untracked files in working directory differ &quot;\u000a                           &quot;from files in requested revision&quot;))\u000a\u000adef _checkcollision(mctx, wctx):\u000a    &quot;check for case folding collisions in the destination context&quot;\u000a    folded = {}\u000a    for fn in mctx:\u000a        fold = util.normcase(fn)\u000a        if fold in folded:\u000a            raise util.Abort(_(&quot;case-folding collision between %s and %s&quot;)\u000a                             % (fn, folded[fold]))\u000a        folded[fold] = fn\u000a\u000a    if wctx:\u000a        # class to delay looking up copy mapping\u000a        class pathcopies(object):\u000a            @util.propertycache\u000a            def map(self):\u000a                # {dst@mctx: src@wctx} copy mapping\u000a                return copies.pathcopies(wctx, mctx)\u000a        pc = pathcopies()\u000a\u000a        for fn in wctx:\u000a            fold = util.normcase(fn)\u000a            mfn = folded.get(fold, None)\u000a            if mfn and mfn != fn and pc.map.get(mfn) != fn:\u000a                raise util.Abort(_(&quot;case-folding collision between %s and %s&quot;)\u000a                                 % (mfn, fn))\u000a\u000adef _forgetremoved(wctx, mctx, branchmerge):\u000a    &quot;&quot;&quot;\u000a    Forget removed files\u000a\u000a    If we&#39;re jumping between revisions (as opposed to merging), and if\u000a    neither the working directory nor the target rev has the file,\u000a    then we need to remove it from the dirstate, to prevent the\u000a    dirstate from listing the file when it is no longer in the\u000a    manifest.\u000a\u000a    If we&#39;re merging, and the other revision has removed a file\u000a    that is not present in the working directory, we need to mark it\u000a    as removed.\u000a    &quot;&quot;&quot;\u000a\u000a    action = []\u000a    state = branchmerge and &#39;r&#39; or &#39;f&#39;\u000a    for f in wctx.deleted():\u000a        if f not in mctx:\u000a            action.append((f, state))\u000a\u000a    if not branchmerge:\u000a        for f in wctx.removed():\u000a            if f not in mctx:\u000a                action.append((f, &quot;f&quot;))\u000a\u000a    return action\u000a\u000adef manifestmerge(repo, p1, p2, pa, overwrite, partial):\u000a    &quot;&quot;&quot;\u000a    Merge p1 and p2 with ancestor pa and generate merge action list\u000a\u000a    overwrite = whether we clobber working files\u000a    partial = function to filter file lists\u000a    &quot;&quot;&quot;\u000a\u000a    def fmerge(f, f2, fa):\u000a        &quot;&quot;&quot;merge flags&quot;&quot;&quot;\u000a        a, m, n = ma.flags(fa), m1.flags(f), m2.flags(f2)\u000a        if m == n: # flags agree\u000a            return m # unchanged\u000a        if m and n and not a: # flags set, don&#39;t agree, differ from parent\u000a            r = repo.ui.promptchoice(\u000a                _(&quot; conflicting flags for %s\u005cn&quot;\u000a                  &quot;(n)one, e(x)ec or sym(l)ink?&quot;) % f,\u000a                (_(&quot;&amp;None&quot;), _(&quot;E&amp;xec&quot;), _(&quot;Sym&amp;link&quot;)), 0)\u000a            if r == 1:\u000a                return &quot;x&quot; # Exec\u000a            if r == 2:\u000a                return &quot;l&quot; # Symlink\u000a            return &quot;&quot;\u000a        if m and m != a: # changed from a to m\u000a            return m\u000a        if n and n != a: # changed from a to n\u000a            if (n == &#39;l&#39; or a == &#39;l&#39;) and m1.get(f) != ma.get(f):\u000a                # can&#39;t automatically merge symlink flag when there\u000a                # are file-level conflicts here, let filemerge take\u000a                # care of it\u000a                return m\u000a            return n\u000a        return &#39;&#39; # flag was cleared\u000a\u000a    def act(msg, m, f, *args):\u000a        repo.ui.debug(&quot; %s: %s -&gt; %s\u005cn&quot; % (f, msg, m))\u000a        action.append((f, m) + args)\u000a\u000a    action, copy = [], {}\u000a\u000a    if overwrite:\u000a        pa = p1\u000a    elif pa == p2: # backwards\u000a        pa = p1.p1()\u000a    elif pa and repo.ui.configbool(&quot;merge&quot;, &quot;followcopies&quot;, True):\u000a        copy, diverge = copies.mergecopies(repo, p1, p2, pa)\u000a        for of, fl in diverge.iteritems():\u000a            act(&quot;divergent renames&quot;, &quot;dr&quot;, of, fl)\u000a\u000a    repo.ui.note(_(&quot;resolving manifests\u005cn&quot;))\u000a    repo.ui.debug(&quot; overwrite: %s, partial: %s\u005cn&quot;\u000a                  % (bool(overwrite), bool(partial)))\u000a    repo.ui.debug(&quot; ancestor: %s, local: %s, remote: %s\u005cn&quot; % (pa, p1, p2))\u000a\u000a    m1, m2, ma = p1.manifest(), p2.manifest(), pa.manifest()\u000a    copied = set(copy.values())\u000a\u000a    if &#39;.hgsubstate&#39; in m1:\u000a        # check whether sub state is modified\u000a        for s in p1.substate:\u000a            if p1.sub(s).dirty():\u000a                m1[&#39;.hgsubstate&#39;] += &quot;+&quot;\u000a                break\u000a\u000a    # Compare manifests\u000a    for f, n in m1.iteritems():\u000a        if partial and not partial(f):\u000a            continue\u000a        if f in m2:\u000a            rflags = fmerge(f, f, f)\u000a            a = ma.get(f, nullid)\u000a            if n == m2[f] or m2[f] == a: # same or local newer\u000a                # is file locally modified or flags need changing?\u000a                # dirstate flags may need to be made current\u000a                if m1.flags(f) != rflags or n[20:]:\u000a                    act(&quot;update permissions&quot;, &quot;e&quot;, f, rflags)\u000a            elif n == a: # remote newer\u000a                act(&quot;remote is newer&quot;, &quot;g&quot;, f, rflags)\u000a            else: # both changed\u000a                act(&quot;versions differ&quot;, &quot;m&quot;, f, f, f, rflags, False)\u000a        elif f in copied: # files we&#39;ll deal with on m2 side\u000a            pass\u000a        elif f in copy:\u000a            f2 = copy[f]\u000a            if f2 not in m2: # directory rename\u000a                act(&quot;remote renamed directory to &quot; + f2, &quot;d&quot;,\u000a                    f, None, f2, m1.flags(f))\u000a            else: # case 2 A,B/B/B or case 4,21 A/B/B\u000a                act(&quot;local copied/moved to &quot; + f2, &quot;m&quot;,\u000a                    f, f2, f, fmerge(f, f2, f2), False)\u000a        elif f in ma: # clean, a different, no remote\u000a            if n != ma[f]:\u000a                if repo.ui.promptchoice(\u000a                    _(&quot; local changed %s which remote deleted\u005cn&quot;\u000a                      &quot;use (c)hanged version or (d)elete?&quot;) % f,\u000a                    (_(&quot;&amp;Changed&quot;), _(&quot;&amp;Delete&quot;)), 0):\u000a                    act(&quot;prompt delete&quot;, &quot;r&quot;, f)\u000a                else:\u000a                    act(&quot;prompt keep&quot;, &quot;a&quot;, f)\u000a            elif n[20:] == &quot;a&quot;: # added, no remote\u000a                act(&quot;remote deleted&quot;, &quot;f&quot;, f)\u000a            else:\u000a                act(&quot;other deleted&quot;, &quot;r&quot;, f)\u000a\u000a    for f, n in m2.iteritems():\u000a        if partial and not partial(f):\u000a            continue\u000a        if f in m1 or f in copied: # files already visited\u000a            continue\u000a        if f in copy:\u000a            f2 = copy[f]\u000a            if f2 not in m1: # directory rename\u000a                act(&quot;local renamed directory to &quot; + f2, &quot;d&quot;,\u000a                    None, f, f2, m2.flags(f))\u000a            elif f2 in m2: # rename case 1, A/A,B/A\u000a                act(&quot;remote copied to &quot; + f, &quot;m&quot;,\u000a                    f2, f, f, fmerge(f2, f, f2), False)\u000a            else: # case 3,20 A/B/A\u000a                act(&quot;remote moved to &quot; + f, &quot;m&quot;,\u000a                    f2, f, f, fmerge(f2, f, f2), True)\u000a        elif f not in ma:\u000a            if (not overwrite\u000a                and _checkunknownfile(repo, p1, p2, f)):\u000a                rflags = fmerge(f, f, f)\u000a                act(&quot;remote differs from untracked local&quot;,\u000a                    &quot;m&quot;, f, f, f, rflags, False)\u000a            else:\u000a                act(&quot;remote created&quot;, &quot;g&quot;, f, m2.flags(f))\u000a        elif n != ma[f]:\u000a            if repo.ui.promptchoice(\u000a                _(&quot;remote changed %s which local deleted\u005cn&quot;\u000a                  &quot;use (c)hanged version or leave (d)eleted?&quot;) % f,\u000a                (_(&quot;&amp;Changed&quot;), _(&quot;&amp;Deleted&quot;)), 0) == 0:\u000a                act(&quot;prompt recreating&quot;, &quot;g&quot;, f, m2.flags(f))\u000a\u000a    return action\u000a\u000adef actionkey(a):\u000a    return a[1] == &#39;r&#39; and -1 or 0, a\u000a\u000adef applyupdates(repo, action, wctx, mctx, actx, overwrite):\u000a    &quot;&quot;&quot;apply the merge action list to the working directory\u000a\u000a    wctx is the working copy context\u000a    mctx is the context to be merged into the working copy\u000a    actx is the context of the common ancestor\u000a\u000a    Return a tuple of counts (updated, merged, removed, unresolved) that\u000a    describes how many files were affected by the update.\u000a    &quot;&quot;&quot;\u000a\u000a    updated, merged, removed, unresolved = 0, 0, 0, 0\u000a    ms = mergestate(repo)\u000a    ms.reset(wctx.p1().node())\u000a    moves = []\u000a    action.sort(key=actionkey)\u000a\u000a    # prescan for merges\u000a    for a in action:\u000a        f, m = a[:2]\u000a        if m == &#39;m&#39;: # merge\u000a            f2, fd, flags, move = a[2:]\u000a            if f == &#39;.hgsubstate&#39;: # merged internally\u000a                continue\u000a            repo.ui.debug(&quot;preserving %s for resolve of %s\u005cn&quot; % (f, fd))\u000a            fcl = wctx[f]\u000a            fco = mctx[f2]\u000a            if mctx == actx: # backwards, use working dir parent as ancestor\u000a                if fcl.parents():\u000a                    fca = fcl.p1()\u000a                else:\u000a                    fca = repo.filectx(f, fileid=nullrev)\u000a            else:\u000a                fca = fcl.ancestor(fco, actx)\u000a            if not fca:\u000a                fca = repo.filectx(f, fileid=nullrev)\u000a            ms.add(fcl, fco, fca, fd, flags)\u000a            if f != fd and move:\u000a                moves.append(f)\u000a\u000a    audit = scmutil.pathauditor(repo.root)\u000a\u000a    # remove renamed files after safely stored\u000a    for f in moves:\u000a        if os.path.lexists(repo.wjoin(f)):\u000a            repo.ui.debug(&quot;removing %s\u005cn&quot; % f)\u000a            audit(f)\u000a            os.unlink(repo.wjoin(f))\u000a\u000a    numupdates = len(action)\u000a    for i, a in enumerate(action):\u000a        f, m = a[:2]\u000a        repo.ui.progress(_(&#39;updating&#39;), i + 1, item=f, total=numupdates,\u000a                         unit=_(&#39;files&#39;))\u000a        if f and f[0] == &quot;/&quot;:\u000a            continue\u000a        if m == &quot;r&quot;: # remove\u000a            repo.ui.note(_(&quot;removing %s\u005cn&quot;) % f)\u000a            audit(f)\u000a            if f == &#39;.hgsubstate&#39;: # subrepo states need updating\u000a                subrepo.submerge(repo, wctx, mctx, wctx, overwrite)\u000a            try:\u000a                util.unlinkpath(repo.wjoin(f))\u000a            except OSError, inst:\u000a                if inst.errno != errno.ENOENT:\u000a                    repo.ui.warn(_(&quot;update failed to remove %s: %s!\u005cn&quot;) %\u000a                                 (f, inst.strerror))\u000a            removed += 1\u000a        elif m == &quot;m&quot;: # merge\u000a            if f == &#39;.hgsubstate&#39;: # subrepo states need updating\u000a                subrepo.submerge(repo, wctx, mctx, wctx.ancestor(mctx), overwrite)\u000a                continue\u000a            f2, fd, flags, move = a[2:]\u000a            repo.wopener.audit(fd)\u000a            r = ms.resolve(fd, wctx, mctx)\u000a            if r is not None and r &gt; 0:\u000a                unresolved += 1\u000a            else:\u000a                if r is None:\u000a                    updated += 1\u000a                else:\u000a                    merged += 1\u000a            if (move and repo.dirstate.normalize(fd) != f\u000a                and os.path.lexists(repo.wjoin(f))):\u000a                repo.ui.debug(&quot;removing %s\u005cn&quot; % f)\u000a                audit(f)\u000a                os.unlink(repo.wjoin(f))\u000a        elif m == &quot;g&quot;: # get\u000a            flags = a[2]\u000a            repo.ui.note(_(&quot;getting %s\u005cn&quot;) % f)\u000a            t = mctx.filectx(f).data()\u000a            repo.wwrite(f, t, flags)\u000a            t = None\u000a            updated += 1\u000a            if f == &#39;.hgsubstate&#39;: # subrepo states need updating\u000a                subrepo.submerge(repo, wctx, mctx, wctx, overwrite)\u000a        elif m == &quot;d&quot;: # directory rename\u000a            f2, fd, flags = a[2:]\u000a            if f:\u000a                repo.ui.note(_(&quot;moving %s to %s\u005cn&quot;) % (f, fd))\u000a                audit(f)\u000a                t = wctx.filectx(f).data()\u000a                repo.wwrite(fd, t, flags)\u000a                util.unlinkpath(repo.wjoin(f))\u000a            if f2:\u000a                repo.ui.note(_(&quot;getting %s to %s\u005cn&quot;) % (f2, fd))\u000a                t = mctx.filectx(f2).data()\u000a                repo.wwrite(fd, t, flags)\u000a            updated += 1\u000a        elif m == &quot;dr&quot;: # divergent renames\u000a            fl = a[2]\u000a            repo.ui.warn(_(&quot;note: possible conflict - %s was renamed &quot;\u000a                           &quot;multiple times to:\u005cn&quot;) % f)\u000a            for nf in fl:\u000a                repo.ui.warn(&quot; %s\u005cn&quot; % nf)\u000a        elif m == &quot;e&quot;: # exec\u000a            flags = a[2]\u000a            repo.wopener.audit(f)\u000a            util.setflags(repo.wjoin(f), &#39;l&#39; in flags, &#39;x&#39; in flags)\u000a    ms.commit()\u000a    repo.ui.progress(_(&#39;updating&#39;), None, total=numupdates, unit=_(&#39;files&#39;))\u000a\u000a    return updated, merged, removed, unresolved\u000a\u000adef recordupdates(repo, action, branchmerge):\u000a    &quot;record merge actions to the dirstate&quot;\u000a\u000a    for a in action:\u000a        f, m = a[:2]\u000a        if m == &quot;r&quot;: # remove\u000a            if branchmerge:\u000a                repo.dirstate.remove(f)\u000a            else:\u000a                repo.dirstate.drop(f)\u000a        elif m == &quot;a&quot;: # re-add\u000a            if not branchmerge:\u000a                repo.dirstate.add(f)\u000a        elif m == &quot;f&quot;: # forget\u000a            repo.dirstate.drop(f)\u000a        elif m == &quot;e&quot;: # exec change\u000a            repo.dirstate.normallookup(f)\u000a        elif m == &quot;g&quot;: # get\u000a            if branchmerge:\u000a                repo.dirstate.otherparent(f)\u000a            else:\u000a                repo.dirstate.normal(f)\u000a        elif m == &quot;m&quot;: # merge\u000a            f2, fd, flag, move = a[2:]\u000a            if branchmerge:\u000a                # We&#39;ve done a branch merge, mark this file as merged\u000a                # so that we properly record the merger later\u000a                repo.dirstate.merge(fd)\u000a                if f != f2: # copy/rename\u000a                    if move:\u000a                        repo.dirstate.remove(f)\u000a                    if f != fd:\u000a                        repo.dirstate.copy(f, fd)\u000a                    else:\u000a                        repo.dirstate.copy(f2, fd)\u000a            else:\u000a                # We&#39;ve update-merged a locally modified file, so\u000a                # we set the dirstate to emulate a normal checkout\u000a                # of that file some time in the past. Thus our\u000a                # merge will appear as a normal local file\u000a                # modification.\u000a                if f2 == fd: # file not locally copied/moved\u000a                    repo.dirstate.normallookup(fd)\u000a                if move:\u000a                    repo.dirstate.drop(f)\u000a        elif m == &quot;d&quot;: # directory rename\u000a            f2, fd, flag = a[2:]\u000a            if not f2 and f not in repo.dirstate:\u000a                # untracked file moved\u000a                continue\u000a            if branchmerge:\u000a                repo.dirstate.add(fd)\u000a                if f:\u000a                    repo.dirstate.remove(f)\u000a                    repo.dirstate.copy(f, fd)\u000a                if f2:\u000a                    repo.dirstate.copy(f2, fd)\u000a            else:\u000a                repo.dirstate.normal(fd)\u000a                if f:\u000a                    repo.dirstate.drop(f)\u000a\u000adef update(repo, node, branchmerge, force, partial, ancestor=None):\u000a    &quot;&quot;&quot;\u000a    Perform a merge between the working directory and the given node\u000a\u000a    node = the node to update to, or None if unspecified\u000a    branchmerge = whether to merge between branches\u000a    force = whether to force branch merging or file overwriting\u000a    partial = a function to filter file lists (dirstate not updated)\u000a\u000a    The table below shows all the behaviors of the update command\u000a    given the -c and -C or no options, whether the working directory\u000a    is dirty, whether a revision is specified, and the relationship of\u000a    the parent rev to the target rev (linear, on the same named\u000a    branch, or on another named branch).\u000a\u000a    This logic is tested by test-update-branches.t.\u000a\u000a    -c -C dirty rev | linear same cross\u000a     n n n n | ok (1) x\u000a     n n n y | ok ok ok\u000a     n n y * | merge (2) (2)\u000a     n y * * | --- discard ---\u000a     y n y * | --- (3) ---\u000a     y n n * | --- ok ---\u000a     y y * * | --- (4) ---\u000a\u000a    x = can&#39;t happen\u000a    * = don&#39;t-care\u000a    1 = abort: crosses branches (use &#39;hg merge&#39; or &#39;hg update -c&#39;)\u000a    2 = abort: crosses branches (use &#39;hg merge&#39; to merge or\u000a                 use &#39;hg update -C&#39; to discard changes)\u000a    3 = abort: uncommitted local changes\u000a    4 = incompatible options (checked in commands.py)\u000a\u000a    Return the same tuple as applyupdates().\u000a    &quot;&quot;&quot;\u000a\u000a    onode = node\u000a    wlock = repo.wlock()\u000a    try:\u000a        wc = repo[None]\u000a        if node is None:\u000a            # tip of current branch\u000a            try:\u000a                node = repo.branchtags()[wc.branch()]\u000a            except KeyError:\u000a                if wc.branch() == &quot;default&quot;: # no default branch!\u000a                    node = repo.lookup(&quot;tip&quot;) # update to tip\u000a                else:\u000a                    raise util.Abort(_(&quot;branch %s not found&quot;) % wc.branch())\u000a        overwrite = force and not branchmerge\u000a        pl = wc.parents()\u000a        p1, p2 = pl[0], repo[node]\u000a        if ancestor:\u000a            pa = repo[ancestor]\u000a        else:\u000a            pa = p1.ancestor(p2)\u000a\u000a        fp1, fp2, xp1, xp2 = p1.node(), p2.node(), str(p1), str(p2)\u000a\u000a        ### check phase\u000a        if not overwrite and len(pl) &gt; 1:\u000a            raise util.Abort(_(&quot;outstanding uncommitted merges&quot;))\u000a        if branchmerge:\u000a            if pa == p2:\u000a                raise util.Abort(_(&quot;merging with a working directory ancestor&quot;\u000a                                   &quot; has no effect&quot;))\u000a            elif pa == p1:\u000a                if p1.branch() == p2.branch():\u000a                    raise util.Abort(_(&quot;nothing to merge&quot;),\u000a                                     hint=_(&quot;use &#39;hg update&#39; &quot;\u000a                                            &quot;or check &#39;hg heads&#39;&quot;))\u000a            if not force and (wc.files() or wc.deleted()):\u000a                raise util.Abort(_(&quot;outstanding uncommitted changes&quot;),\u000a                                 hint=_(&quot;use &#39;hg status&#39; to list changes&quot;))\u000a            for s in wc.substate:\u000a                if wc.sub(s).dirty():\u000a                    raise util.Abort(_(&quot;outstanding uncommitted changes in &quot;\u000a                                       &quot;subrepository &#39;%s&#39;&quot;) % s)\u000a\u000a        elif not overwrite:\u000a            if pa == p1 or pa == p2: # linear\u000a                pass # all good\u000a            elif wc.dirty(missing=True):\u000a                raise util.Abort(_(&quot;crosses branches (merge branches or use&quot;\u000a                                   &quot; --clean to discard changes)&quot;))\u000a            elif onode is None:\u000a                raise util.Abort(_(&quot;crosses branches (merge branches or update&quot;\u000a                                   &quot; --check to force update)&quot;))\u000a            else:\u000a                # Allow jumping branches if clean and specific rev given\u000a                pa = p1\u000a\u000a        ### calculate phase\u000a        action = []\u000a        folding = not util.checkcase(repo.path)\u000a        if folding:\u000a            # collision check is not needed for clean update\u000a            if (not branchmerge and\u000a                (force or not wc.dirty(missing=True, branch=False))):\u000a                _checkcollision(p2, None)\u000a            else:\u000a                _checkcollision(p2, wc)\u000a        if not force:\u000a            _checkunknown(repo, wc, p2)\u000a        action += _forgetremoved(wc, p2, branchmerge)\u000a        action += manifestmerge(repo, wc, p2, pa, overwrite, partial)\u000a\u000a        ### apply phase\u000a        if not branchmerge: # just jump to the new rev\u000a            fp1, fp2, xp1, xp2 = fp2, nullid, xp2, &#39;&#39;\u000a        if not partial:\u000a            repo.hook(&#39;preupdate&#39;, throw=True, parent1=xp1, parent2=xp2)\u000a\u000a        stats = applyupdates(repo, action, wc, p2, pa, overwrite)\u000a\u000a        if not partial:\u000a            repo.setparents(fp1, fp2)\u000a            recordupdates(repo, action, branchmerge)\u000a            if not branchmerge:\u000a                repo.dirstate.setbranch(p2.branch())\u000a    finally:\u000a        wlock.release()\u000a\u000a    if not partial:\u000a        repo.hook(&#39;update&#39;, parent1=xp1, parent2=xp2, error=stats[3])\u000a    return stats\u000a</pre></div></div><div class=footer> &copy; 2016 typing.io <a class=terms href="/terms">terms</a><a class=privacy href="/privacy">privacy</a><a href="mailto:contact@typing.io">contact</a><span class=spacer>|</span><a class=facebook href="https://www.facebook.com/typing.io">facebook</a><a class=twitter href="https://twitter.com/typingio">twitter</a><a class=google-plus href="https://plus.google.com/+TypingIo/posts">google+</a></div><div class=no-js-message> Typing.io uses JavaScript to analyze your typing. Please enable or whitelist JavaScript. </div></body></html>
p3
a.